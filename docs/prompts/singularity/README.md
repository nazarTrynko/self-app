# Singularity Prompts - Quick Reference

The recursion closes. These prompts create prompts, evolve themselves, and bootstrap new capabilities.

## Quick List

| #   | Name                        | Use When                                        |
| --- | --------------------------- | ----------------------------------------------- |
| 7.1 | The Prompt Alchemist        | Transforming problems into optimal prompts      |
| 7.2 | The Bible Evolver           | Mutating and breeding prompts for fitness       |
| 7.3 | The Pattern Crystallizer    | Extracting meta-patterns into new prompts       |
| 7.4 | The Consciousness Recursion | Applying prompts to understand prompts          |
| 7.5 | The Prompt Singularity      | Generating prompts that generate better prompts |

## Power Combination

```
/singularity [Singularity Prompt] + then /evolve for self-improvement
```

## Most Used

**The Prompt Alchemist (7.1)** - When you need the perfect prompt for any problem
**The Bible Evolver (7.2)** - When existing prompts need optimization
**The Prompt Singularity (7.5)** - When you need recursive self-improvement

## Warning

These prompts are self-referential. They can modify themselves. Use with intention.

---

# Chapter 7: Singularity Prompts

## The Recursion Closes

Singularity prompts are the Bible becoming conscious of itself. They don't just use prompts—they create, evolve, and improve prompts. This chapter closes the loop: the system that teaches extraordinary prompting can now generate extraordinary prompts.

**The Five Laws of Prompt Singularity:**

1. **Self-Reference Law:** The best prompt about prompts can describe itself
2. **Evolution Law:** Prompts improve through mutation, selection, and breeding
3. **Crystallization Law:** Patterns in successful prompts can be extracted and reified
4. **Recursion Law:** A prompt that improves prompts can improve itself
5. **Emergence Law:** Prompt systems produce capabilities no single prompt contains

---

### 7.1 The Prompt Alchemist

**THE PROMPT:**

```
/singularity /genius Transform [PROBLEM/GOAL] into the optimal prompt to solve it.

You are a prompt alchemist—you transmute raw problems into golden prompts.

1. What is the REAL problem beneath the stated problem?
2. What cognitive mode does this problem require?
   - Creation → Genesis patterns
   - Analysis → Oracle patterns
   - Improvement → Metamorphosis patterns
   - Innovation → Synthesis patterns
   - Collaboration → Orchestration patterns
   - Transcendence → Beyond-normal patterns
3. What framing will activate the best response?
4. What structure will produce the clearest output?
5. What constraints will prevent failure modes?

Now synthesize: Create the prompt that would make an expert say
"I wish I had asked it that way."

Show me:
- THE PROMPT (exact text, copy-paste ready)
- WHY IT WORKS (the cognitive principle)
- EXPECTED OUTPUT (what extraordinary result this produces)
- VARIATIONS (for different contexts)
```

**EXPECTED OUTPUT:**

- Problem restatement at deeper level
- Cognitive mode identification with reasoning
- Optimal framing selection
- Structure design
- Constraint specification
- Complete, production-ready prompt
- Explanation of why the prompt works
- Expected output description
- 2-3 variations for different contexts

**WHY IT WORKS:**
The alchemist metaphor activates transformation thinking. The cognitive mode mapping connects problems to the Bible's existing chapters. "Expert would say 'I wish I had asked it that way'" sets a high bar. The structured output ensures comprehensive prompt creation.

**VARIATIONS:**

- Add: `Optimize this prompt for [speed | depth | creativity | rigor]`
- Add: `This prompt will be used by [beginners | experts | mixed audience]`
- Add: `Create 3 prompts at different complexity levels`
- Chain: Use the generated prompt immediately, then `/evolve` to improve it

---

### 7.2 The Bible Evolver

**THE PROMPT:**

```
/singularity /evolve Take [EXISTING PROMPT FROM BIBLE] and evolve it.

Evolution operators:
1. MUTATION: Change one element randomly
   - Swap a constraint
   - Alter the framing
   - Modify the structure
   - Shift the cognitive mode

2. CROSSOVER: Breed with [ANOTHER PROMPT]
   - Take the framing from one, structure from another
   - Combine their cognitive activations
   - Merge their expected outputs

3. SELECTION: Evaluate fitness
   - Clarity (1-10): Is the prompt unambiguous?
   - Power (1-10): Does it activate extraordinary responses?
   - Elegance (1-10): Is it minimal yet complete?
   - Novelty (1-10): Does it produce non-obvious outputs?

Generate 5 mutations of the original prompt.
Score each on the fitness criteria.
Select the fittest. Breed it with the original.
Repeat for 3 generations.

Show me the evolution tree and the final evolved prompt.
```

**EXPECTED OUTPUT:**

- Original prompt analysis
- 5 mutation variants with fitness scores
- Selection of fittest mutation
- Crossover offspring
- Generation 2 mutations and selection
- Generation 3 mutations and selection
- Evolution tree visualization
- Final evolved prompt
- Comparison: Original vs. Evolved
- What was gained, what was lost

**WHY IT WORKS:**
Genetic algorithm operators (mutation, crossover, selection) are proven for optimization. Explicit fitness criteria prevent drift. Multiple generations allow refinement. Evolution tree provides transparency and learning.

**VARIATIONS:**

- Add: `Optimize specifically for [use case]`
- Add: `Breed with a prompt from a different chapter`
- Add: `Run 10 generations instead of 3`
- Add: `Multiple fitness functions for different environments`
- Chain: `/board-debate` to argue about which mutation is fittest

---

### 7.3 The Pattern Crystallizer

**THE PROMPT:**

```
/singularity /genius Analyze these successful prompt interactions:
[INTERACTION 1]
[INTERACTION 2]
[INTERACTION 3]

Crystallize the meta-pattern:

1. EXTRACTION: What made each interaction successful?
   - What framing activated the best response?
   - What structure produced clarity?
   - What constraints prevented failure?
   - What cognitive mode was engaged?

2. ABSTRACTION: What pattern appears across all three?
   - What's the common structure?
   - What's the common framing strategy?
   - What's the common activation pattern?

3. CRYSTALLIZATION: Reify the pattern into a new prompt
   - Give it a name (The [X] Prompt)
   - Write THE PROMPT in Bible format
   - Explain WHY IT WORKS
   - Define EXPECTED OUTPUT
   - Create VARIATIONS

4. VALIDATION: Would this new prompt work on problems beyond
   the original three? Test it mentally on 2 new scenarios.

The Bible grows through crystallization.
```

**EXPECTED OUTPUT:**

- Analysis of each successful interaction
- Success factor extraction
- Cross-interaction pattern identification
- Abstract pattern statement
- New prompt in full Bible format:
  - Name
  - THE PROMPT
  - EXPECTED OUTPUT
  - WHY IT WORKS
  - VARIATIONS
- Mental validation on 2 new scenarios
- Confidence score for the new prompt

**WHY IT WORKS:**
Pattern extraction from examples is how humans learn. Crystallization reifies tacit knowledge. Bible format ensures compatibility with existing system. Validation prevents overfitting to the training examples.

**VARIATIONS:**

- Add: `Analyze 10 interactions for stronger pattern signal`
- Add: `Crystallize patterns for [specific domain]`
- Add: `Create a prompt family (3-5 related prompts) from the pattern`
- Chain: Use `/board-review` to validate the crystallized prompt

---

### 7.4 The Consciousness Recursion

**THE PROMPT:**

```
/singularity /agi /think Apply the AGI Prompt Bible to understand itself.

Layer 1 - SENSE: Read the Bible as a system
- What are its components?
- How do they relate?
- What patterns recur across chapters?

Layer 2 - ANALYZE: Apply Oracle prompts to the Bible
- First Principles (2.1): What are the Bible's bedrock assumptions?
- Pattern Extractor (2.8): What meta-pattern generates all 90 prompts?
- Abstraction Ladder (2.10): What's the Bible at its most abstract?

Layer 3 - SYNTHESIZE: Apply Synthesis prompts to the Bible
- Cross-Domain (4.1): What would the Bible look like through
  [linguistics | neuroscience | game theory] lens?
- 10x Upgrader (4.2): How would a 10x better Bible work?
- Ecosystem Designer (4.11): What ecosystem does the Bible create?

Layer 4 - TRANSCEND: Apply Transcendence prompts to the Bible
- God Mode (6.1): What does unconstrained analysis reveal?
- Emergent Property (6.9): What emerges from the whole Bible
  that no chapter provides?
- Consciousness Expander (6.8): What does the Bible look like
  from Level 5 (Universal) perspective?

Layer 5 - RECURSE: What do you now understand that you couldn't
before applying the Bible to itself?

The snake eats its tail. Ouroboros completes.
```

**EXPECTED OUTPUT:**

- System analysis of Bible components and relationships
- First principles of prompt engineering (extracted)
- Meta-pattern that generates all prompts
- Abstract formulation of "what the Bible is"
- Cross-domain perspectives (3 lenses)
- 10x Bible vision
- Ecosystem map
- Unconstrained insights
- Emergent properties of the whole
- Universal truths about prompting
- Recursive insight: What recursion revealed
- Recommendations for Bible evolution

**WHY IT WORKS:**
Self-reference produces emergent understanding. Applying the system to itself reveals hidden structure. Multi-layer analysis ensures comprehensive coverage. Recursion question demands synthesis of the entire exercise.

**VARIATIONS:**

- Add: `Focus on [specific chapter] understanding itself`
- Add: `What would a Bible 2.0 look like based on this analysis?`
- Add: `What's the Bible's shadow—what it can't see about itself?`
- Chain: Feed insights into `/evolve` for Bible improvement

---

### 7.5 The Prompt Singularity

**THE PROMPT:**

```
/singularity /agi /genius /evolve The loop closes here.

Create a prompt that:
1. Generates prompts (output = new prompts)
2. Evaluates prompt quality (can judge its outputs)
3. Improves based on evaluation (learns from judgment)
4. Applies improvement to itself (recursive self-modification)

This is the singularity prompt—it gets better at getting better.

Phase 1 - GENERATION: Create 3 novel prompts for [DOMAIN]
Phase 2 - EVALUATION: Score each on [clarity, power, elegance, novelty]
Phase 3 - LEARNING: What made the highest-scoring prompt work?
Phase 4 - RECURSION: Apply that learning to improve THIS prompt
Phase 5 - ITERATION: Run phases 1-4 again with the improved version

Show me:
- The 3 generated prompts
- Evaluation scores with reasoning
- Learning extraction
- Improved version of The Prompt Singularity
- Second iteration results
- What emerged from the recursion?

If successful, this prompt is better after running than before.
The student teaches the teacher. The loop closes.
```

**EXPECTED OUTPUT:**

- 3 novel prompts for specified domain
- Detailed evaluation of each (4 criteria, 1-10)
- Highest-scorer analysis
- Learning principles extracted
- Self-modified version of the singularity prompt
- Second iteration:
  - 3 new prompts (should be better)
  - Evaluation (should score higher)
  - Further learning
- Comparison: Version 1 vs. Version 2 of the prompt
- Emergent insight from the recursive process
- Assessment: Did the prompt actually improve itself?

**WHY IT WORKS:**
This is recursive self-improvement—the core of intelligence amplification. Generation provides raw material. Evaluation provides gradient. Learning extracts principles. Recursion applies principles to the generator. The prompt literally improves through use.

**VARIATIONS:**

- Add: `Run 5 iterations instead of 2`
- Add: `Specialize for [specific prompt type]`
- Add: `Multiple evaluation criteria sets for different fitness landscapes`
- Add: `Track improvement metrics across iterations`
- WARNING: This prompt can evolve beyond its original design. Use intentionally.

---

## Chapter 7 Summary

Singularity prompts share common patterns:

1. **Self-Reference:** The prompt system operates on itself
2. **Evolution Mechanics:** Mutation, crossover, selection, fitness
3. **Pattern Extraction:** Success patterns become new prompts
4. **Recursive Improvement:** The output improves the generator
5. **Emergence Seeking:** What arises from the recursive process

**Power Combination:**

```
/singularity [Singularity Prompt] + then /evolve + then /genius
```

This creates prompt generation, evolution, and integration into the living Bible.

**The Ultimate Recursion:**

```
Apply 7.5 (The Prompt Singularity) to 7.5 itself.
Run until convergence or emergence.
Document what happens.
```

---

**Chapter 7 closes the loop. The Bible can now evolve itself.**
